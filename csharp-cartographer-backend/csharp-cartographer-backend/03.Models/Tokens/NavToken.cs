using csharp_cartographer_backend._01.Configuration;
using csharp_cartographer_backend._02.Utilities.Helpers;
using csharp_cartographer_backend._03.Models.Tokens.TokenMaps;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text.Json.Serialization;

namespace csharp_cartographer_backend._03.Models.Tokens
{
    /// <summary>
    ///     A Model Definition for the NavToken class.
    /// </summary>
    public class NavToken
    {
        /// <summary>The unique identifier for a NavToken.</summary>
        public Guid ID { get; set; }

        /// <summary>The index value for the token in the list of NavTokens.</summary>
        public int Index { get; set; }

        /// <summary>The text string value of the token.</summary>
        public string Text { get; set; }

        /// <summary>The Roslyn SyntaxKind of the token.</summary>
        [JsonIgnore]
        public SyntaxKind Kind { get; set; }

        /// <summary>The Roslyn SyntaxKind of the token as a string.</summary>
        public string RoslynKind { get; set; }

        /// <summary>The token classification.</summary>
        public string? RoslynClassification { get; set; }

        /// <summary>The updated token classification.</summary>
        [JsonIgnore]
        public string? UpdatedClassification { get; set; }

        /// <summary> </summary>
        public SemanticMap Map { get; set; }

        /// <summary>The TextSpan of the token text.</summary>
        [JsonIgnore]
        public TextSpan Span { get; set; }

        /// <summary>A list of the tokens leading trivia strings.</summary>
        public List<string> LeadingTrivia { get; set; } = [];

        /// <summary>A list of the tokens trailing trivia strings.</summary>
        public List<string> TrailingTrivia { get; set; } = [];

        /// <summary>The Roslyn generated SyntaxToken.</summary>
        [JsonIgnore]
        public SyntaxToken RoslynToken { get; set; }

        /// <summary>The token that comes before this one sequentially.</summary>
        [JsonIgnore]
        public NavToken? PrevToken { get; set; }

        /// <summary>The token that comes after this one sequentially.</summary>
        [JsonIgnore]
        public NavToken? NextToken { get; set; }

        /// <summary>The Roslyn generated SyntaxNode of the token's parent.</summary>
        [JsonIgnore]
        public SyntaxNode? Parent { get; set; }

        /// <summary>The Roslyn generated SyntaxKind of the token's parent as a string.</summary>
        [JsonIgnore]
        public string? ParentNodeKind { get; set; }

        /// <summary>The Roslyn generated SyntaxKind of the token's grand parent as a string.</summary>
        [JsonIgnore]
        public string? GrandParentNodeKind { get; set; }

        /// <summary>The Roslyn generated SyntaxKind of the token's great grand parent as a string.</summary>
        [JsonIgnore]
        public string? GreatGrandParentNodeKind { get; set; }

        /// <summary>The Roslyn generated SyntaxKind of the token's great great grand parent as a string.</summary>
        [JsonIgnore]
        public string? GreatGreatGrandParentNodeKind { get; set; }

        /// <summary> </summary>
        [JsonIgnore]
        public AncestorNodeKinds AncestorKinds { get; set; }

        /// <summary>The token's semantic data.</summary>
        [JsonIgnore]
        public TokenSemanticData? SemanticData { get; set; }

        /// <summary>The color the token will be highlighted in the UI.</summary>
        public string? HighlightColor { get; set; }

        /// <summary>A list of token tags attached to the token.</summary>
        public List<TokenTag> Tags { get; set; } = [];

        /// <summary>A list of ancestor nodes & data attached to the token.</summary>
        public List<TokenChart> Charts { get; set; } = [];

        public NavToken()
        {
        }

        /// <summary>Constructor for the NavToken model.</summary>
        /// <param name="roslynToken">The SyntaxToken generated by the Roslyn code analysis library.</param>
        /// <param name="index">The index of the token in the list.</param>
        public NavToken(SyntaxToken roslynToken, int index)
        {
            ID = Guid.NewGuid();
            Index = index;

            // Lexical data
            Text = roslynToken.Text;
            Kind = roslynToken.Kind();
            RoslynKind = roslynToken.Kind().ToString();
            Span = roslynToken.Span;
            LeadingTrivia = GetLeadingTrivia(roslynToken);
            TrailingTrivia = GetTrailingTrivia(roslynToken);
            RoslynToken = roslynToken;
            Parent = GetAncestorNode(roslynToken, 1);

            // Syntax data
            ParentNodeKind = GetAncestorNodeKind(roslynToken, 1);
            GrandParentNodeKind = GetAncestorNodeKind(roslynToken, 2);
            GreatGrandParentNodeKind = GetAncestorNodeKind(roslynToken, 3);
            GreatGreatGrandParentNodeKind = GetAncestorNodeKind(roslynToken, 4);
            AncestorKinds = GetAncestorKinds(roslynToken);
        }

        public bool IsDelimiter() => GlobalConstants.Delimiters.Contains(Text);

        public bool IsPunctuation() => GlobalConstants.Punctuators.Contains(Text);

        public bool IsOperator() => GlobalConstants.Operators.Contains(Text);

        public bool IsIdentifier() => RoslynToken.IsKind(SyntaxKind.IdentifierToken);

        public bool IsAccessStaticMember() =>
            HasAncestorAt(1, SyntaxKind.SimpleMemberAccessExpression);

        private bool HasAncestor(SyntaxKind kind)
        {
            var ancestors = AncestorKinds.Ancestors;
            return !ancestors.IsEmpty
                && ancestors.Contains(kind);
        }

        private bool HasAncestorAt(int index, SyntaxKind kind)
        {
            var ancestors = AncestorKinds.Ancestors;
            return !ancestors.IsEmpty
                && index >= 0
                && index < ancestors.Length
                && ancestors[index] == kind;
        }

        public bool IsReturnValue()
        {
            bool isValidToken = Kind == SyntaxKind.IdentifierToken
                || Kind == SyntaxKind.DefaultKeyword
                || SyntaxFacts.IsLiteralExpression(Kind);

            return isValidToken && HasAncestorAt(1, SyntaxKind.ReturnStatement);
        }

        public bool IsImplicitParameterKeyword()
        {
            // Won't handle identifiers named "value".
            // TODO: Add check for Accessor ancestor
            return Kind == SyntaxKind.IdentifierToken
                && Text == "value";
        }

        public bool IsInterpolatedValue()
        {
            return HasAncestorAt(1, SyntaxKind.Interpolation)
                && PrevToken?.Text == "{"
                && NextToken?.Text == "}";
        }

        public bool IsDefaultOperand()
        {
            return HasAncestorAt(1, SyntaxKind.DefaultExpression);
        }

        public bool IsNameOfOperand()
        {
            return HasAncestorAt(1, SyntaxKind.Argument)
                && PrevToken?.PrevToken?.Text == "nameof";
        }

        public bool IsSizeOfOperand()
        {
            return HasAncestorAt(1, SyntaxKind.SizeOfExpression);
        }

        public bool IsTypeOfOperand()
        {
            return HasAncestorAt(1, SyntaxKind.TypeOfExpression);
        }

        #region Delimiter Checks
        public bool IsAccessorListDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.AccessorList)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsAddAccessorBlockDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Block)
                && HasAncestorAt(1, SyntaxKind.AddAccessorDeclaration)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsAnonymousObjectCreationExpressionDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.AnonymousObjectCreationExpression)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsArgumentListDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.ArgumentList)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsArrayInitializationDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.ArrayInitializerExpression)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsArrayTypeDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.ArrayRankSpecifier)
                && HasAncestorAt(1, SyntaxKind.ArrayType)
                && (Kind == SyntaxKind.OpenBracketToken || Kind == SyntaxKind.CloseBracketToken);
        }

        public bool IsAttributeListDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.AttributeList)
                && (Kind == SyntaxKind.OpenBracketToken || Kind == SyntaxKind.CloseBracketToken);
        }

        public bool IsAttributeArgumentListDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.AttributeArgumentList)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsBracketedArgumentListDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.BracketedArgumentList)
                && (Kind == SyntaxKind.OpenBracketToken || Kind == SyntaxKind.CloseBracketToken);
        }

        public bool IsCastTypeDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.CastExpression)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsCatchArgumentDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.CatchDeclaration)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsCatchBlockDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Block)
                && HasAncestorAt(1, SyntaxKind.CatchClause)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsCheckedStatementBlockDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Block)
                && HasAncestorAt(1, SyntaxKind.CheckedStatement)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsCatchFilterDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.CatchFilterClause)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsClassDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.ClassDeclaration)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsCollectionInitializerExpressionDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.CollectionInitializerExpression)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsConstructorDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Block)
                && HasAncestorAt(1, SyntaxKind.ConstructorDeclaration)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsCollectionExpressionDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.CollectionExpression)
                && (Kind == SyntaxKind.OpenBracketToken || Kind == SyntaxKind.CloseBracketToken);
        }

        public bool IsDefaultExpressionDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.DefaultExpression)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsForEachBlockDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Block)
                && HasAncestorAt(1, SyntaxKind.ForEachStatement)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsForEachControlDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.ForEachStatement)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsForLoopBlockDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Block)
                && HasAncestorAt(1, SyntaxKind.ForStatement)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsForLoopControlDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.ForStatement)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsWhileLoopBlockDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Block)
                && HasAncestorAt(1, SyntaxKind.WhileStatement)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsWithInitializerExpressionDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.WithInitializerExpression)
                && HasAncestorAt(1, SyntaxKind.WithExpression)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsWhileLoopConditionDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.WhileStatement)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsIfBlockDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Block)
                && HasAncestorAt(1, SyntaxKind.IfStatement)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsIfConditionDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.IfStatement)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsImplicitArrayCreationDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.ImplicitArrayCreationExpression)
                && (Kind == SyntaxKind.OpenBracketToken || Kind == SyntaxKind.CloseBracketToken);
        }

        public bool IsTupleExpressionDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.TupleExpression)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsTupleTypeDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.TupleType)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsTypeArgumentListDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.TypeArgumentList)
                && (Kind == SyntaxKind.LessThanToken || Kind == SyntaxKind.GreaterThanToken);
        }

        public bool IsTypeParameterListDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.TypeParameterList)
                && (Kind == SyntaxKind.LessThanToken || Kind == SyntaxKind.GreaterThanToken);
        }

        public bool IsMethodDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Block)
                && HasAncestorAt(1, SyntaxKind.MethodDeclaration)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsNamespaceDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.NamespaceDeclaration)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsObjectInitializerDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.ObjectInitializerExpression)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsPropertyPatternDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.PropertyPatternClause)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsRecordDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.RecordDeclaration)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsRemoveAccessorBlockDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Block)
                && HasAncestorAt(1, SyntaxKind.RemoveAccessorDeclaration)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsSetAccessorBlockDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Block)
                && HasAncestorAt(1, SyntaxKind.SetAccessorDeclaration)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsSwitchExpressionDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.SwitchExpression)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsSwitchStatementDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.SwitchStatement)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsSwitchStatementConditionDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.SwitchStatement)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsTryBlockDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Block)
                && HasAncestorAt(1, SyntaxKind.TryStatement)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsParameterListDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.ParameterList)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsParenthesizedExpressionDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.ParenthesizedExpression)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsParenthesizedPatternDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.ParenthesizedPattern)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsInterpolatedValueDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Interpolation)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }

        public bool IsSizeOfExpressionDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.SizeOfExpression)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsTypeOfExpressionDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.TypeOfExpression)
                && (Kind == SyntaxKind.OpenParenToken || Kind == SyntaxKind.CloseParenToken);
        }

        public bool IsUncheckedStatementBlockDelimiter()
        {
            return IsDelimiter()
                && HasAncestorAt(0, SyntaxKind.Block)
                && HasAncestorAt(1, SyntaxKind.UncheckedStatement)
                && (Kind == SyntaxKind.OpenBraceToken || Kind == SyntaxKind.CloseBraceToken);
        }
        #endregion

        #region Identifier Checks
        public bool IsAttributeArgument()
        {
            return HasAncestorAt(0, SyntaxKind.IdentifierName)
                && HasAncestorAt(1, SyntaxKind.NameEquals)
                && HasAncestorAt(2, SyntaxKind.AttributeArgument);
        }

        public bool IsBaseType()
        {
            return Kind == SyntaxKind.IdentifierToken &&
                HasAncestorAt(1, SyntaxKind.SimpleBaseType);
        }

        public bool IsCastType()
        {
            return (Kind == SyntaxKind.IdentifierToken || IsPredefinedType())
                && HasAncestorAt(1, SyntaxKind.CastExpression);
        }

        public bool IsCastTargetType()
        {
            return HasAncestorAt(1, SyntaxKind.AsExpression)
                && PrevToken?.Text == "as";
        }

        public bool IsDiscard()
        {
            return Kind == SyntaxKind.UnderscoreToken
                && HasAncestorAt(0, SyntaxKind.DiscardPattern);
        }

        public bool IsExceptionType()
        {
            return Kind == SyntaxKind.IdentifierToken &&
                HasAncestorAt(1, SyntaxKind.CatchDeclaration);
        }

        public bool IsForEachLoopCollectionIdentifier()
        {
            return HasAncestorAt(0, SyntaxKind.IdentifierName)
                && HasAncestorAt(1, SyntaxKind.ForEachStatement)
                && NextToken?.Text == ")";
        }

        public bool IsMethodInvocation()
        {
            var nextTokenText = NextToken?.Text;
            var hasPermittedNextToken = nextTokenText == "(" || nextTokenText == "<";
            var hasInvocationAncestor =
                HasAncestorAt(1, SyntaxKind.InvocationExpression) ||
                HasAncestorAt(2, SyntaxKind.InvocationExpression);

            return hasPermittedNextToken && hasInvocationAncestor;
        }

        public bool IsGenericMethodInvocation() => IsMethodInvocation()
            && NextToken?.Text == "<";

        public bool IsObjectCreationExpression()
        {
            if (HasAncestorAt(1, SyntaxKind.ObjectCreationExpression))
                return true;

            // alias qualified constructors
            return HasAncestorAt(1, SyntaxKind.QualifiedName)
                && HasAncestorAt(2, SyntaxKind.ObjectCreationExpression)
                && PrevToken?.Kind == SyntaxKind.DotToken;
        }

        public bool IsObjCreationPropertyAssignment()
        {
            return RoslynClassification is not null
                && RoslynClassification == "identifier"
                && HasAncestorAt(1, SyntaxKind.SimpleAssignmentExpression)
                && HasAncestorAt(2, SyntaxKind.ObjectInitializerExpression);
        }

        public bool IsParameterLabel()
        {
            return Kind == SyntaxKind.IdentifierToken &&
                HasAncestorAt(1, SyntaxKind.NameColon) &&
                NextToken?.Text == ":";
        }

        public bool IsPropertyOrEnumMemberReference()
        {
            return Kind == SyntaxKind.IdentifierToken
                && HasAncestorAt(1, SyntaxKind.SimpleMemberAccessExpression)
                && !HasAncestorAt(2, SyntaxKind.SimpleMemberAccessExpression)
                && PrevToken?.Kind == SyntaxKind.DotToken;
        }

        public bool IsTypeConstraint()
        {
            if (Kind == SyntaxKind.QuestionToken)
                return false;

            return HasAncestorAt(1, SyntaxKind.TypeParameterConstraintClause)
                || HasAncestorAt(2, SyntaxKind.TypeParameterConstraintClause);
        }

        public bool IsTypeReference()
        {
            return Kind == SyntaxKind.IdentifierToken
                && HasAncestorAt(0, SyntaxKind.GenericName)
                && HasAncestorAt(1, SyntaxKind.TypeArgumentList);
        }

        /*
         *  -----------------------------------------------------------------------
         *      Declaration Identifiers
         *  -----------------------------------------------------------------------
         */

        public bool IsAttributeDeclaration() =>
            HasAncestorAt(1, SyntaxKind.Attribute);

        public bool IsClassDeclaration() =>
            HasAncestorAt(0, SyntaxKind.ClassDeclaration);

        public bool IsClassConstructorDeclaration() =>
            RoslynClassification is not null &&
            RoslynClassification == "class name" &&
            HasAncestorAt(0, SyntaxKind.ConstructorDeclaration);

        public bool IsDelegateDeclaration() =>
            HasAncestorAt(0, SyntaxKind.DelegateDeclaration);

        public bool IsEnumDeclaration() =>
            HasAncestorAt(0, SyntaxKind.EnumDeclaration);

        public bool IsEnumMemberDeclaration() =>
            HasAncestorAt(0, SyntaxKind.EnumMemberDeclaration);

        public bool IsEventPropertyDeclaration()
        {
            return Kind == SyntaxKind.IdentifierToken
                && HasAncestorAt(0, SyntaxKind.EventDeclaration);
        }

        public bool IsEventFieldDeclaration() =>
            HasAncestorAt(0, SyntaxKind.VariableDeclarator) &&
            HasAncestorAt(1, SyntaxKind.VariableDeclaration) &&
            HasAncestorAt(2, SyntaxKind.EventFieldDeclaration);

        public bool IsFieldDeclaration() =>
            HasAncestorAt(0, SyntaxKind.VariableDeclarator) &&
            HasAncestorAt(2, SyntaxKind.FieldDeclaration);

        public bool IsLocalVariableDeclaration() =>
            HasAncestorAt(2, SyntaxKind.LocalDeclarationStatement)
            && !HasAncestorAt(0, SyntaxKind.GenericName)
            && !HasAncestorAt(0, SyntaxKind.IdentifierName);

        public bool IsForLoopIteratorDeclaration()
        {
            return HasAncestorAt(0, SyntaxKind.VariableDeclarator)
                && HasAncestorAt(1, SyntaxKind.VariableDeclaration)
                && HasAncestorAt(2, SyntaxKind.ForStatement);
        }

        public bool IsForEachLoopIteratorDeclaration()
        {
            return Kind == SyntaxKind.IdentifierToken
                && HasAncestorAt(0, SyntaxKind.ForEachStatement)
                && NextToken?.Text == "in";
        }

        public bool IsMethodDeclaration() =>
            HasAncestorAt(0, SyntaxKind.MethodDeclaration);

        public bool IsGenericMethodDeclaration() =>
            IsMethodDeclaration() && NextToken?.Text == "<";

        public bool IsParameterDeclaration() =>
            HasAncestorAt(0, SyntaxKind.Parameter);

        public bool IsPropertyDeclaration() =>
            HasAncestorAt(0, SyntaxKind.PropertyDeclaration);

        public bool IsRecordDeclaration() =>
            HasAncestorAt(0, SyntaxKind.RecordDeclaration);

        public bool IsRecordConstructorDeclaration() =>
            RoslynClassification is not null &&
            RoslynClassification == "record class name" &&
            HasAncestorAt(0, SyntaxKind.ConstructorDeclaration);

        public bool IsRecordStructDeclaration() =>
            HasAncestorAt(0, SyntaxKind.RecordStructDeclaration);

        public bool IsRecordStructConstructorDeclaration() =>
            RoslynClassification is not null &&
            RoslynClassification == "record struct name" &&
            HasAncestorAt(0, SyntaxKind.ConstructorDeclaration);

        public bool IsStructDeclaration() =>
            HasAncestorAt(0, SyntaxKind.StructDeclaration);

        public bool IsStructConstructorDeclaration() =>
            RoslynClassification is not null &&
            RoslynClassification == "struct name" &&
            HasAncestorAt(0, SyntaxKind.ConstructorDeclaration);

        /*
         *  -----------------------------------------------------------------------
         *      Reference Identifiers
         *  -----------------------------------------------------------------------
         */

        public bool IsFieldReference() => SemanticData?.SymbolKind == SymbolKind.Field
            && SemanticData.OperationKind == OperationKind.FieldReference;

        /*
         *  -----------------------------------------------------------------------
         *      DataType Identifiers
         *  -----------------------------------------------------------------------
         */

        public bool IsArrayDataType()
        {
            return HasAncestorAt(1, SyntaxKind.ArrayType);
        }

        public bool IsEventFieldType()
        {
            // covers nullable and non-nullable types
            return HasAncestorAt(2, SyntaxKind.EventFieldDeclaration)
                || HasAncestorAt(3, SyntaxKind.EventFieldDeclaration);
        }

        public bool IsEventPropertyDataType()
        {
            return HasAncestorAt(0, SyntaxKind.IdentifierName)
                && HasAncestorAt(1, SyntaxKind.EventDeclaration);
        }

        public bool IsFieldDataType() =>
            HasAncestorAt(2, SyntaxKind.FieldDeclaration) ||
            HasAncestorAt(3, SyntaxKind.FieldDeclaration);

        public bool IsLocalType() => IsLocalVariableDataType()
            || IsForEachLoopLocalVariableDataType();

        public bool IsLocalVariableDataType()
        {
            if (NextToken?.Text == "[")
                return false;

            return HasAncestorAt(2, SyntaxKind.LocalDeclarationStatement)
                || HasAncestorAt(3, SyntaxKind.LocalDeclarationStatement);
        }

        public bool IsForEachLoopLocalVariableDataType()
        {
            return HasAncestorAt(1, SyntaxKind.ForEachStatement)
                && NextToken?.Text != ")";
        }

        public bool IsForLoopIteratorDataType()
        {
            // covers pre-defined types: for (int i = 0; ...)
            if (HasAncestorAt(0, SyntaxKind.PredefinedType)
                && HasAncestorAt(1, SyntaxKind.VariableDeclaration)
                && HasAncestorAt(2, SyntaxKind.ForStatement)
                && PrevToken?.Text == "(")
            {
                return true;
            }

            // covers ref types: for (Node n = start; ...)
            if (HasAncestorAt(0, SyntaxKind.IdentifierName)
                && HasAncestorAt(1, SyntaxKind.VariableDeclaration)
                && HasAncestorAt(2, SyntaxKind.ForStatement)
                && PrevToken?.Text == "(")
            {
                return true;
            }

            // covers nullable ref types: for (Node n = start; ...)
            if (HasAncestorAt(0, SyntaxKind.IdentifierName)
                && HasAncestorAt(1, SyntaxKind.NullableType)
                && HasAncestorAt(2, SyntaxKind.VariableDeclaration)
                && HasAncestorAt(3, SyntaxKind.ForStatement)
                && PrevToken?.Text == "(")
            {
                return true;
            }

            return false;
        }

        public bool IsForEachLoopIteratorDataType()
        {
            return HasAncestorAt(1, SyntaxKind.ForEachStatement)
                && NextToken?.Text != ")";
        }

        public bool IsTupleElementName()
            => HasAncestorAt(0, SyntaxKind.TupleElement);

        public bool IsTupleElementType()
            => HasAncestorAt(1, SyntaxKind.TupleElement);

        public bool IsMethodReturnType()
        {
            if (IsTupleElementName() || IsTupleElementType())
                return false;

            if (HasAncestorAt(0, SyntaxKind.TypeParameter))
                return false;

            if (HasAncestorAt(1, SyntaxKind.TypeParameterConstraintClause))
                return false;

            return HasAncestorAt(1, SyntaxKind.MethodDeclaration)
                || HasAncestorAt(2, SyntaxKind.MethodDeclaration);
        }

        public bool IsTypeParameter()
        {
            // doesn't work for method declarations: GetValue<T>()
            // works for type param return types & type param constraints & as generic args
            return SemanticData?.SymbolKind == SymbolKind.TypeParameter;
        }

        public bool IsDelegateReturnType()
        {
            if (IsTupleElementName() || IsTupleElementType())
                return false;

            return HasAncestorAt(1, SyntaxKind.DelegateDeclaration)
                || HasAncestorAt(2, SyntaxKind.DelegateDeclaration);
        }

        public bool IsOutVariableDataType()
        {
            return HasAncestorAt(0, SyntaxKind.IdentifierName)
                && HasAncestorAt(1, SyntaxKind.DeclarationExpression)
                && PrevToken?.Text == "out";
        }

        public bool IsParameterDataType() =>
            HasAncestorAt(1, SyntaxKind.Parameter) ||
            HasAncestorAt(2, SyntaxKind.Parameter);

        public bool IsPropertyDataType() =>
            HasAncestorAt(1, SyntaxKind.PropertyDeclaration) ||
            HasAncestorAt(2, SyntaxKind.PropertyDeclaration);

        /*
         *  -----------------------------------------------------------------------
         *      Alias / Qualifier Identifiers
         *  -----------------------------------------------------------------------
         */

        public bool IsUsingDirectiveQualifier()
        {
            // skips using keyword, DotToken and SemiColonToken in using directives
            if (RoslynClassification is not ("namespace name" or "identifier"))
                return false;

            // skips alias declarations
            if (NextToken?.Text == "=")
                return false;

            return AncestorKinds.Ancestors.Contains(SyntaxKind.UsingDirective);
        }

        public bool IsNamespaceDeclarationQualifier()
        {
            // skip using dir qualifiers that are shared between using dirs and namespace declaration
            if (AncestorKinds.Ancestors.LastOrDefault() == SyntaxKind.UsingDirective)
                return false;

            // for single segment namespace declarations
            if (RoslynClassification is not null
                && RoslynClassification == "namespace name"
                && AncestorKinds.GetLast() == SyntaxKind.NamespaceDeclaration
                && PrevToken?.Text == "namespace")
            {
                return true;
            }

            // for a namespace defined in a namespace
            if (RoslynClassification is not null
                && RoslynClassification == "namespace name"
                && AncestorKinds.GetLast() == SyntaxKind.NamespaceDeclaration
                && AncestorKinds.GetSecondToLast() == SyntaxKind.NamespaceDeclaration)
            {
                return true;
            }

            return RoslynClassification is not null
                && RoslynClassification == "namespace name"
                && AncestorKinds.GetLast() == SyntaxKind.NamespaceDeclaration
                && AncestorKinds.GetSecondToLast() == SyntaxKind.QualifiedName;
        }

        public bool IsNamespaceQualifier()
        {
            // skip using dir qualifiers
            if (AncestorKinds.GetLast() == SyntaxKind.UsingDirective)
                return false;

            if (RoslynClassification is not null && RoslynClassification == "namespace name")
                return true;

            bool hasValidKind = Kind == SyntaxKind.IdentifierToken;
            bool hasQualifiedNameAncestor = HasAncestor(SyntaxKind.QualifiedName);
            bool isAlias = IsAliasQualifier();

            if (hasValidKind && hasQualifiedNameAncestor && !isAlias)
            {
                return true;
            }

            if (SemanticData?.SymbolKind == SymbolKind.Namespace)
            {
                return true;
            }

            return false;
        }

        public bool IsAliasDeclarationIdentifier()
        {
            // covers namespace & type aliases
            return HasAncestorAt(0, SyntaxKind.IdentifierName)
                && HasAncestorAt(1, SyntaxKind.NameEquals)
                && PrevToken?.Text == "using";
        }

        public bool IsNamespaceAliasDeclarationIdentifier()
        {
            if (SemanticData is null)
                return false;

            // alias declarations only appear in using statements, other instances are alias references
            if (AncestorKinds.GetLast() != SyntaxKind.UsingDirective)
                return false;

            //       ⌄
            // using IO = System.IO;
            bool hasValidTarget = SemanticData.AliasTargetSymbol?.Kind
                is SymbolKind.Namespace
                or SymbolKind.ErrorType; // default to namespace alias if target symbol can't be identified

            return SemanticData.IsAlias && hasValidTarget;
        }

        public bool IsTypeAliasDeclarationIdentifier()
        {
            if (SemanticData is null)
                return false;

            // alias declarations only appear in using statements, other instances are alias references
            if (AncestorKinds.GetLast() != SyntaxKind.UsingDirective)
                return false;

            //          ⌄
            // using Handler = System.Action<int>;
            return SemanticData.IsAlias
                && SemanticData.AliasTargetSymbol?.Kind == SymbolKind.NamedType;
        }

        public bool IsAliasQualifier()
        {
            // skip using dir aliases
            if (AncestorKinds.GetLast() == SyntaxKind.UsingDirective)
                return false;

            return SemanticData?.IsAlias == true;

            ////                    ⌄
            //// var token = new MyToken.NavToken();
            //if (HasAncestorAt(0, SyntaxKind.IdentifierName)
            //    && HasAncestorAt(1, SyntaxKind.QualifiedName)
            //    && !HasAncestorAt(2, SyntaxKind.QualifiedName)
            //    && PrevToken?.Text != "."
            //    && NextToken?.Text == ".")
            //    return true;

            ////        ⌄
            //// return IO.File.Exists(path);
            //if (HasAncestorAt(0, SyntaxKind.IdentifierName)
            //    && HasAncestorAt(1, SyntaxKind.SimpleMemberAccessExpression)
            //    && PrevToken?.Text != "."
            //    && NextToken?.Text == "."
            //    && SemanticData?.SymbolKind == SymbolKind.Namespace
            //    && SemanticData?.MemberTypeKind == SymbolKind.Alias)
            //    return true;

            //return false;
        }

        public bool IsTypeQualifier()
        {
            // skips 
            if (NextToken?.Text != ".")
                return false;

            // skips query expression vars when they ref a property
            //               ⌄
            // let doubled = n.Value * 2 
            if (IsQueryExpressionVariable())
                return false;

            //           ⌄
            // System.Console.WriteLine(text);
            if (PrevToken?.Text == ".")
                return HasAncestorAt(0, SyntaxKind.IdentifierName)
                    && HasAncestorAt(1, SyntaxKind.SimpleMemberAccessExpression)
                    && HasAncestorAt(2, SyntaxKind.SimpleMemberAccessExpression)
                    && PrevToken?.PrevToken?.Map?.SemanticRole is SemanticRole.NamespaceQualifer or SemanticRole.AliasQualifier;

            //    ⌄                         ⌄
            // Console.WriteLine(text);    Guid.NewGuid();
            if (PrevToken?.Text != ".")
                return HasAncestorAt(0, SyntaxKind.IdentifierName)
                    && HasAncestorAt(1, SyntaxKind.SimpleMemberAccessExpression);

            return false;
        }

        /*
         *  -----------------------------------------------------------------------
         *      Query Expression Identifiers
         *  -----------------------------------------------------------------------
         */

        public bool IsQueryExpressionVariable()
        {
            List<SyntaxKind> kinds =
            [
                SyntaxKind.FromClause,
                SyntaxKind.LetClause,
                SyntaxKind.JoinClause,
                SyntaxKind.QueryContinuation,
                SyntaxKind.QueryBody,
                SyntaxKind.QueryExpression,
                SyntaxKind.WhereClause,
                SyntaxKind.WhenClause,
                SyntaxKind.GroupClause,
                SyntaxKind.OrderByClause,
                SyntaxKind.SelectClause,
                SyntaxKind.AscendingOrdering,
                SyntaxKind.DescendingOrdering,
            ];

            foreach (var kind in AncestorKinds.Ancestors)
            {
                if (kinds.Contains(kind))
                    return true;
            }

            return false;
        }

        public bool IsRangeVariable()
        {
            //                  ⌄
            // var query = from n in numbers
            return HasAncestorAt(0, SyntaxKind.FromClause)
                && HasAncestorAt(1, SyntaxKind.QueryExpression)
                && PrevToken?.Text == "from";
        }

        public bool IsQueryVariableReference()
        {
            // TODO: split this into specific query exp vars (not reliable)
            //                                       ⌄
            // from n in numbers join l in labels on n.Id
            return SemanticData?.SymbolKind == SymbolKind.RangeVariable;
        }

        public bool IsQuerySource()
        {
            //                          ⌄
            // var query = from n in numbers
            return HasAncestorAt(0, SyntaxKind.IdentifierName)
                && HasAncestorAt(1, SyntaxKind.FromClause)
                && PrevToken?.Text == "in";
        }

        public bool IsJoinRangeVariable()
        {
            //      ⌄
            // join l in labels on n.Id equals l.Id
            return HasAncestorAt(0, SyntaxKind.JoinClause)
                && HasAncestorAt(1, SyntaxKind.QueryBody)
                && PrevToken?.Text == "join";
        }

        public bool IsJoinSource()
        {
            //             ⌄
            // join l in labels on n.Id equals l.Id
            return HasAncestorAt(0, SyntaxKind.IdentifierName)
                && HasAncestorAt(1, SyntaxKind.JoinClause)
                && PrevToken?.Text == "in";
        }

        public bool IsLetVariable()
        {
            //        ⌄
            // let doubled = n.Value * 2
            return HasAncestorAt(0, SyntaxKind.LetClause)
                && HasAncestorAt(1, SyntaxKind.QueryBody)
                && PrevToken?.Text == "let";
        }

        public bool IsGroupContinuationRangeVariable()
        {
            //                                             ⌄
            // group new { n, l, doubled } by n.Value into g
            return HasAncestorAt(0, SyntaxKind.QueryContinuation)
                && HasAncestorAt(1, SyntaxKind.QueryBody)
                && PrevToken?.Text == "into";
        }

        public bool IsJoinIntoRangeVariable()
        {
            //                                              ⌄
            // join l in labels on n.Id equals l.Id into matches
            return HasAncestorAt(0, SyntaxKind.JoinIntoClause)
                && HasAncestorAt(1, SyntaxKind.JoinClause)
                && PrevToken?.Text == "into";
        }
        #endregion

        #region Keyword Checks
        public bool IsKeyword()
        {
            return SyntaxFacts.IsKeywordKind(Kind)
                || IsNameofAndKeyword()
                || IsValueAndKeyword()
                || IsVarAndKeyword();
        }

        public bool IsContextualKeyword() => SyntaxFacts.IsContextualKeyword(Kind);

        public bool IsNameofAndKeyword()
        {
            // for some reason nameof isn't considered a keyword but sizeof & typeof are...
            return Kind == SyntaxKind.IdentifierToken
                && HasAncestorAt(1, SyntaxKind.InvocationExpression)
                && NextToken?.Text == "(";
        }

        public bool IsValueAndKeyword()
        {
            // covers implicit accessor parameters
            return Kind == SyntaxKind.IdentifierToken
                && Text == "value";
        }

        public bool IsVarAndKeyword()
        {
            // covers out variable data type
            return Kind == SyntaxKind.IdentifierToken
                && PrevToken?.Text == "out";
        }

        public bool IsDefaultOperatorKeyword()
        {
            return Kind == SyntaxKind.DefaultKeyword
                && HasAncestorAt(0, SyntaxKind.DefaultExpression);
        }

        public bool IsDefaultValueKeyword()
        {
            return Kind == SyntaxKind.DefaultKeyword
                && HasAncestorAt(0, SyntaxKind.DefaultLiteralExpression);
        }

        public bool IsTypeConstraintKeyword()
        {
            return Kind.ToString().Contains("Keyword")
                && HasAncestorAt(1, SyntaxKind.TypeParameterConstraintClause);
        }

        public bool IsTypeDeclarationKeyword()
        {
            return GlobalConstants.TypeDeclarationKeywords.Contains(Text)
                && !HasAncestorAt(1, SyntaxKind.TypeParameterConstraintClause);
        }

        public bool IsWithExpressionKeyword()
        {
            return Kind == SyntaxKind.WithKeyword
                && HasAncestorAt(0, SyntaxKind.WithExpression);
        }
        #endregion

        #region Literal Checks
        public bool IsNumericLiteral()
        {
            return RoslynClassification is not null
                && RoslynClassification == "number"
                && Kind == SyntaxKind.NumericLiteralToken
                && HasAncestorAt(0, SyntaxKind.NumericLiteralExpression);
        }

        public bool IsBooleanLiteral() =>
            Kind == SyntaxKind.TrueKeyword || Kind == SyntaxKind.FalseKeyword;

        public bool IsCharacterLiteral()
        {
            return RoslynClassification is not null
                && RoslynClassification == "string"
                && Kind == SyntaxKind.CharacterLiteralToken
                && HasAncestorAt(0, SyntaxKind.CharacterLiteralExpression);
        }

        public bool IsNullLiteral() => Kind == SyntaxKind.NullKeyword;

        public bool IsQuotedString()
        {
            return RoslynClassification is not null
                && RoslynClassification == "string"
                && Kind == SyntaxKind.StringLiteralToken
                && HasAncestorAt(0, SyntaxKind.StringLiteralExpression);
        }

        public bool IsVerbatimString()
        {
            return RoslynClassification is not null
                && RoslynClassification == "string - verbatim"
                && Kind == SyntaxKind.StringLiteralToken
                && HasAncestorAt(0, SyntaxKind.StringLiteralExpression);
        }

        public bool IsInterpolatedString()
        {
            return RoslynClassification is not null
                && RoslynClassification == "string"
                &&
                    (
                        Kind == SyntaxKind.InterpolatedStringStartToken ||
                        Kind == SyntaxKind.InterpolatedStringTextToken ||
                        Kind == SyntaxKind.InterpolatedStringEndToken
                    );
        }

        public bool IsInterpolatedVerbatimString()
        {
            return RoslynClassification is not null
                && RoslynClassification == "string - verbatim"
                &&
                    (
                        Kind == SyntaxKind.InterpolatedVerbatimStringStartToken ||
                        Kind == SyntaxKind.InterpolatedStringTextToken ||
                        Kind == SyntaxKind.InterpolatedStringEndToken
                    );
        }
        #endregion

        #region Operator Checks
        public bool IsArithmeticOperator() =>
            Text is "+" or "-" or "*" or "/" or "%" or "++" or "--";

        public bool IsAssignmentOperator() =>
            Text is "=" or "+=" or "-=" or "*=" or "/=" or "%=" or "&=" or "|=" or "^=" or "<<=" or ">>=" or ">>>=";

        public bool IsBitwiseShiftOperator() =>
            Text is "&" or "|" or "^" or "~" or "<<" or ">>" or ">>>";

        public bool IsBooleanLogicalOperator() =>
            Text is "!" or "&" or "|" or "^" or "&&" or "||";

        public bool IsComparisonOperator() =>
            Text is "<" or ">" or "<=" or ">=" or "==" or "!=";

        public bool IsNameOfOperator()
        {
            return Text == "nameof";
        }

        public bool IsSizeOfOperator()
        {
            return Kind == SyntaxKind.SizeOfKeyword
                && HasAncestorAt(0, SyntaxKind.SizeOfExpression);
        }

        public bool IsTernaryOperator()
        {
            if (Kind != SyntaxKind.QuestionToken && Kind != SyntaxKind.ColonToken)
                return false;

            return HasAncestorAt(0, SyntaxKind.ConditionalExpression);
        }

        public bool IsTypeOfOperator()
        {
            return Kind == SyntaxKind.TypeOfKeyword
                && HasAncestorAt(0, SyntaxKind.TypeOfExpression);
        }

        public bool IsIndexOrRangeOperator()
        {
            // index
            if (Kind == SyntaxKind.CaretToken && HasAncestorAt(0, SyntaxKind.IndexExpression))
                return true;

            // range
            if (Kind == SyntaxKind.DotDotToken && HasAncestorAt(0, SyntaxKind.RangeExpression))
                return true;

            return false;
        }

        public bool IsLambdaOperator() => Text is "=>";

        public bool IsLogicalNotOperator()
        {
            return HasAncestorAt(0, SyntaxKind.LogicalNotExpression);
        }

        public bool IsMemberAccessOperator() => Kind == SyntaxKind.DotToken
            && HasAncestorAt(0, SyntaxKind.SimpleMemberAccessExpression);

        public bool IsConditionalMemberAccessOperator() => Kind == SyntaxKind.DotToken
            && HasAncestorAt(0, SyntaxKind.MemberBindingExpression);

        public bool IsConcatenationAddOperator() => Kind == SyntaxKind.PlusToken
            && (PrevToken?.Kind == SyntaxKind.StringLiteralToken
            || NextToken?.Kind == SyntaxKind.StringLiteralToken);

        public bool IsNamespaceAliasQualifier() => Kind == SyntaxKind.ColonColonToken
            && HasAncestorAt(0, SyntaxKind.AliasQualifiedName);

        public bool IsNullConditionalGuard() => Kind == SyntaxKind.QuestionToken
            && HasAncestorAt(0, SyntaxKind.ConditionalAccessExpression);

        public bool IsNullCoalescingOperator() =>
            Kind == SyntaxKind.QuestionQuestionToken &&
            HasAncestorAt(0, SyntaxKind.CoalesceExpression);

        public bool IsNullCoalescingAssignmentOperator() =>
            Kind == SyntaxKind.QuestionQuestionEqualsToken &&
            HasAncestorAt(0, SyntaxKind.CoalesceAssignmentExpression);

        public bool IsNullForgivingOperator() =>
            Kind == SyntaxKind.ExclamationToken &&
            HasAncestorAt(0, SyntaxKind.SuppressNullableWarningExpression);

        public bool IsPointerOperator() =>
            Text is "&" or "*" or "->";
        #endregion

        #region Punctuation Checks
        public bool IsAnonymousObjectMemberDeclarationSeparator()
        {
            return Kind == SyntaxKind.CommaToken
                && HasAncestorAt(0, SyntaxKind.AnonymousObjectCreationExpression);
        }

        public bool IsArgumentSeparator()
        {
            return RoslynClassification is not null
                && RoslynClassification == "punctuation"
                && HasAncestorAt(0, SyntaxKind.ArgumentList)
                && Text == ",";
        }

        public bool IsArrayInitializerElementSeparator()
        {
            return Kind == SyntaxKind.CommaToken
                && HasAncestorAt(0, SyntaxKind.ArrayInitializerExpression);
        }

        public bool IsAttributeArgumentSeparator()
        {
            return Kind == SyntaxKind.CommaToken
                && HasAncestorAt(0, SyntaxKind.AttributeArgumentList);
        }

        public bool IsBaseTypeSeparator()
        {
            return RoslynClassification is not null
                && RoslynClassification == "punctuation"
                && HasAncestorAt(0, SyntaxKind.BaseList)
                && Text == ":";
        }

        public bool IsCollectionExpressionElementSeparator()
        {
            return Kind == SyntaxKind.CommaToken
                && HasAncestorAt(0, SyntaxKind.CollectionExpression);
        }

        public bool IsCollectionInitializerElementSeparator()
        {
            return Kind == SyntaxKind.CommaToken
                && HasAncestorAt(0, SyntaxKind.CollectionInitializerExpression);
        }

        public bool IsConstraintSeparator()
        {
            return Kind == SyntaxKind.ColonToken
                && HasAncestorAt(0, SyntaxKind.TypeParameterConstraintClause);
        }

        public bool IsEnumMemberSeparator()
        {
            return RoslynClassification is not null
                && RoslynClassification == "punctuation"
                && HasAncestorAt(0, SyntaxKind.EnumDeclaration)
                && Text == ",";
        }

        public bool IsMemberPatternSeparator()
        {
            return Kind == SyntaxKind.ColonToken
                && HasAncestorAt(0, SyntaxKind.NameColon)
                && HasAncestorAt(1, SyntaxKind.Subpattern);
        }

        public bool IsOrderByClauseSeparator()
        {
            return Kind == SyntaxKind.CommaToken
                && HasAncestorAt(0, SyntaxKind.OrderByClause);
        }

        public bool IsQualifiedNameSeparator()
        {
            return HasAncestorAt(0, SyntaxKind.QualifiedName);
        }

        public bool IsNullableTypeMarker() => Kind == SyntaxKind.QuestionToken
            && HasAncestorAt(0, SyntaxKind.NullableType);

        public bool IsNullableConstraintTypeMarker()
        {
            if (Kind != SyntaxKind.QuestionToken)
                return false;

            return HasAncestorAt(0, SyntaxKind.ClassConstraint)
                || HasAncestorAt(0, SyntaxKind.StructConstraint);
        }

        public bool IsParameterSeparator()
        {
            return RoslynClassification is not null
                && RoslynClassification == "punctuation"
                && HasAncestorAt(0, SyntaxKind.ParameterList)
                && Text == ",";
        }

        public bool IsPropertyInitializationSeparator()
        {
            return Kind == SyntaxKind.CommaToken
                && HasAncestorAt(0, SyntaxKind.ObjectInitializerExpression);
        }

        public bool IsTypeArgumentSeperator() => Kind == SyntaxKind.CommaToken
            && HasAncestorAt(0, SyntaxKind.TypeArgumentList);

        public bool IsTypeParameterSeparator() => Kind == SyntaxKind.CommaToken
            && HasAncestorAt(0, SyntaxKind.TypeParameterList);

        public bool IsSwitchArmSeperator() => Kind == SyntaxKind.CommaToken
            && HasAncestorAt(0, SyntaxKind.SwitchExpression);

        public bool IsTupleElementSeperator()
        {
            if (Kind != SyntaxKind.CommaToken)
                return false;

            return HasAncestorAt(0, SyntaxKind.TupleType)
                || HasAncestorAt(0, SyntaxKind.TupleExpression);
        }

        public bool IsTypeParameterConstraintClauseSeperator()
        {
            return RoslynClassification is not null
                && RoslynClassification == "punctuation"
                && HasAncestorAt(0, SyntaxKind.TypeParameterConstraintClause)
                && Text == ":";
        }

        public bool IsVariableDeclaratorSeparator()
        {
            return RoslynClassification is not null
                && RoslynClassification == "punctuation"
                && HasAncestorAt(0, SyntaxKind.VariableDeclaration)
                && Text == ",";
        }

        public bool IsStatementTerminator()
        {
            return RoslynClassification is not null
                && RoslynClassification == "punctuation"
                && Text == ";";
        }

        public bool IsSwitchCaseLabelTerminator() => Kind == SyntaxKind.ColonToken
            && HasAncestorAt(0, SyntaxKind.CaseSwitchLabel);

        public bool IsSwitchCasePatternLabelTerminator()
        {
            return Kind == SyntaxKind.ColonToken
                && HasAncestorAt(0, SyntaxKind.CasePatternSwitchLabel);
        }

        public bool IsDefaultCaseLabelTerminator()
        {
            return Kind == SyntaxKind.ColonToken
                && HasAncestorAt(0, SyntaxKind.DefaultSwitchLabel);
        }

        public bool IsParameterLabelTerminator()
        {
            return Kind == SyntaxKind.ColonToken
                && HasAncestorAt(0, SyntaxKind.NameColon)
                && HasAncestorAt(1, SyntaxKind.Argument);
        }
        #endregion

        #region Type Checks
        public bool IsAnonymousObjectCreation()
        {
            return HasAncestorAt(0, SyntaxKind.AnonymousObjectCreationExpression);
        }

        public bool IsArgument()
        {
            // single token identifiers
            if (HasAncestorAt(0, SyntaxKind.IdentifierName)
                && HasAncestorAt(1, SyntaxKind.Argument))
            {
                return true;
            }

            // numeric literals
            if (HasAncestorAt(0, SyntaxKind.NumericLiteralExpression)
                && HasAncestorAt(1, SyntaxKind.Argument))
            {
                return true;
            }

            // string literals
            if (HasAncestorAt(0, SyntaxKind.StringLiteralExpression)
                && HasAncestorAt(1, SyntaxKind.Argument))
            {
                return true;
            }

            return false;
        }

        public bool IsGenericTypeArgument()
        {
            //        ⌄
            // List<string> LeadingTrivia { get; set; }
            if (HasAncestorAt(1, SyntaxKind.TypeArgumentList)
                && PrevToken?.Text == "<"
                && NextToken?.Text == ">")
            {
                return true;
            }

            //         ⌄
            // List<string?> LeadingTrivia { get; set; }
            if (HasAncestorAt(2, SyntaxKind.TypeArgumentList)
                && PrevToken?.Text == "<"
                && NextToken?.Text == "?")
            {
                return true;
            }

            //       ⌄
            // Func<int, int> square = x => x * x;
            if (HasAncestorAt(1, SyntaxKind.TypeArgumentList)
                && PrevToken?.Text == "<"
                && NextToken?.Text == ",")
            {
                return true;
            }

            //            ⌄
            // Func<int, int> square = x => x * x;
            if (HasAncestorAt(1, SyntaxKind.TypeArgumentList)
                && PrevToken?.Text == ","
                && NextToken?.Text == ">")
            {
                return true;
            }

            //       ⌄
            // Func<int?, int> square = x => x * x;
            if (HasAncestorAt(2, SyntaxKind.TypeArgumentList)
                && PrevToken?.Text == "<"
                && NextToken?.Text == ",")
            {
                return true;
            }

            //            ⌄
            // Func<int, int?> square = x => x * x;
            if (HasAncestorAt(2, SyntaxKind.TypeArgumentList)
                && PrevToken?.Text == ","
                && NextToken?.Text == "?")
            {
                return true;
            }

            return false;
        }

        public bool IsGenericType() =>
            HasAncestorAt(0, SyntaxKind.GenericName) &&
            !IsMethodInvocation();

        public bool IsGenericTypeParameter() => HasAncestorAt(0, SyntaxKind.TypeParameter);

        public bool IsNullableType() => HasAncestorAt(1, SyntaxKind.NullableType);

        public bool IsNullableConstraintType() => IsTypeConstraint() && NextToken?.Text == "?";

        public bool IsPredefinedType() => SyntaxFacts.IsPredefinedType(Kind);

        public bool IsTypeParameterConstraint()
        {
            return HasAncestorAt(0, SyntaxKind.IdentifierName)
                && HasAncestorAt(1, SyntaxKind.TypeParameterConstraintClause);
        }

        public bool IsTypePatternType() =>
            HasAncestorAt(1, SyntaxKind.ConstantPattern) ||
            HasAncestorAt(1, SyntaxKind.DeclarationPattern) ||
            HasAncestorAt(1, SyntaxKind.IsExpression) ||
            HasAncestorAt(1, SyntaxKind.RecursivePattern);
        #endregion

        /// <summary>Gets the token's leading trivia.</summary>
        /// <param name="roslynToken">The SyntaxToken generated by the Roslyn code analysis library.</param>
        /// <returns>A list of leading trivia strings.</returns>
        private static List<string> GetLeadingTrivia(SyntaxToken roslynToken)
        {
            if (!roslynToken.HasLeadingTrivia)
                return [];

            List<string> leadingTriviaStrings = [];

            foreach (var trivia in roslynToken.LeadingTrivia)
            {
                if (trivia.IsKind(SyntaxKind.SingleLineDocumentationCommentTrivia))
                {
                    leadingTriviaStrings.AddRange(GetLeadingSingleLineDocumentationCommentTrivia(trivia.ToString()));
                    continue;
                }
                else if (trivia.IsKind(SyntaxKind.MultiLineCommentTrivia))
                {
                    leadingTriviaStrings.AddRange(GetLeadingMultilineCommentTrivia(trivia.ToString()));
                    continue;
                }

                leadingTriviaStrings.Add(trivia.ToString());

                if (trivia.IsKind(SyntaxKind.RegionDirectiveTrivia)
                    || trivia.IsKind(SyntaxKind.EndRegionDirectiveTrivia))
                {
                    leadingTriviaStrings.Add(SyntaxFactory.EndOfLine("\r\n").ToString());
                }
            }

            return leadingTriviaStrings;
        }

        /// <summary>Splits a SingleLineDocumentationCommentTrivia trivia into multiple strings.</summary>
        /// <param name="triviaString">The trivia string that needs to be split.</param>
        /// <returns>A leading single-line documentation comment trivia split into a list of strings.</returns>
        private static List<string> GetLeadingSingleLineDocumentationCommentTrivia(string triviaString)
        {
            List<string> triviaToAdd = [];
            triviaString = "///" + triviaString;

            if (StringHelpers.CountOccurrences(triviaString, "///") == 1)
            {
                triviaToAdd.Add(triviaString);
                triviaToAdd.Add(SyntaxFactory.EndOfLine("\r\n").ToString());
            }
            if (StringHelpers.CountOccurrences(triviaString, "///") > 1)
            {
                var newStrings = triviaString.Split("\r\n");

                var count = 1;
                var numOfStrings = newStrings.Length;
                foreach (var newString in newStrings)
                {
                    // handle scenarios where comments have extra spaces
                    if (StringHelpers.HasSequentialSpaces(newString))
                    {
                        var spacesString = StringHelpers.PullSequentialSpaces(newString);
                        triviaToAdd.Add(spacesString);
                    }

                    triviaToAdd.Add(newString.Trim());
                    if (count < numOfStrings)
                    {
                        // add additional line break trivia for multi-line comments
                        triviaToAdd.Add(SyntaxFactory.EndOfLine("\r\n").ToString());
                    }
                    count++;
                }
            }
            return triviaToAdd;
        }

        /// <summary>Splits a MultilineCommentTrivia trivia into multiple strings.</summary>
        /// <param name="triviaString">The trivia string that needs to be split.</param>
        /// <returns>A list of leading multi-line comment trivia strings.</returns>
        private static List<string> GetLeadingMultilineCommentTrivia(string triviaString)
        {
            List<string> triviaToAdd = [];
            var newStrings = triviaString.Split("\r\n");

            var count = 1;
            var numOfStrings = newStrings.Length;
            foreach (var newString in newStrings)
            {
                // check if string has sequential spaces
                // if so, cut them and create a new space trivia with them
                if (StringHelpers.HasSequentialSpaces(newString))
                {
                    var spacesString = StringHelpers.PullSequentialSpaces(newString);
                    triviaToAdd.Add(spacesString);
                }

                // add new trivia strings
                triviaToAdd.Add(newString.Trim());
                if (count < numOfStrings)
                {
                    triviaToAdd.Add(SyntaxFactory.EndOfLine("\r\n").ToString());
                }
                count++;
            }
            return triviaToAdd;
        }

        /// <summary>Gets the token's trailing trivia.</summary>
        /// <param name="roslynToken">The SyntaxToken generated by the Roslyn code analysis library.</param>
        /// <returns>A list of trailing trivia strings.</returns>
        private static List<string> GetTrailingTrivia(SyntaxToken roslynToken)
        {
            if (!roslynToken.HasTrailingTrivia)
                return [];

            List<string> trailingTriviaStrings = [];
            foreach (var trivia in roslynToken.TrailingTrivia)
            {
                // handle trailing trivia that contains "\n" instead of "\r\n"
                if (trivia.IsKind(SyntaxKind.EndOfLineTrivia))
                {
                    trailingTriviaStrings.Add(SyntaxFactory.EndOfLine("\r\n").ToString());
                    continue;
                }
                trailingTriviaStrings.Add(trivia.ToString());
            }
            return trailingTriviaStrings;
        }

        /// <summary>Returns the SyntaxKind of the ancestor node at the specified level.</summary>
        /// <param name="roslynToken">The SyntaxToken generated by the Roslyn code analysis library.</param>
        /// <param name="level">The number of ancestors to climb in the syntax tree.</param>
        /// <returns>The ancestor node kind if found; otherwise, <c>null</c>.</returns>
        private static string? GetAncestorNodeKind(SyntaxToken roslynToken, int level)
        {
            var ancestor = GetAncestorNode(roslynToken, level);
            return ancestor?.Kind().ToString();
        }

        /// <summary>Returns the ancestor SyntaxNode at the specified level.</summary>
        /// <param name="roslynToken">The SyntaxToken generated by the Roslyn code analysis library.</param>
        /// <param name="level">The number of ancestors to climb in the syntax tree.</param>
        /// <returns>The ancestor node if found; otherwise, <c>null</c>.</returns>
        private static SyntaxNode? GetAncestorNode(SyntaxToken roslynToken, int level)
        {
            SyntaxNode? currentNode = roslynToken.Parent;
            for (int i = 1; i < level && currentNode is not null; i++)
            {
                currentNode = currentNode.Parent;
            }
            return currentNode;
        }

        /// <summary>Returns the SyntaxKind of the ancestor nodes in a struct.</summary>
        /// <param name="roslynToken">The SyntaxToken generated by the Roslyn code analysis library.</param>
        /// <returns>The ancestor node kinds.</returns>
        private static AncestorNodeKinds GetAncestorKinds(SyntaxToken roslynToken)
        {
            var builder = ImmutableArray.CreateBuilder<SyntaxKind>();
            SyntaxNode? currentNode = roslynToken.Parent;

            while (currentNode is not null)
            {
                if (!currentNode.IsKind(SyntaxKind.CompilationUnit))
                {
                    builder.Add(currentNode.Kind());
                }
                currentNode = currentNode.Parent;
            }

            return new AncestorNodeKinds(builder.ToImmutable());
        }
    }
}
